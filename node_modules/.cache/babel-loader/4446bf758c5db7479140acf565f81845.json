{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Anisoara Bacrau\\\\Desktop\\\\an3\\\\PDM\\\\ionic\\\\PDM-IonicApp\\\\src\\\\todo\\\\BeautyProvider.tsx\";\nimport React, { useCallback, useContext, useEffect, useReducer } from \"react\";\nimport { getLogger } from \"../core\";\nimport { createBeauties, getBeauties, newWebSocket, updateBeauties, eraseBeauty } from \"./beautyApi\";\nimport { AuthContext } from \"../auth\";\nimport { Plugins } from \"@capacitor/core\";\nconst {\n  Storage\n} = Plugins;\nconst log = getLogger(\"BeautyProvider\");\nconst initialState = {\n  fetching: false,\n  saving: false,\n  deleting: false,\n  oldBeauty: undefined\n};\nconst FETCH_ITEMS_STARTED = \"FETCH_ITEMS_STARTED\";\nconst FETCH_ITEMS_SUCCEEDED = \"FETCH_ITEMS_SUCCEEDED\";\nconst FETCH_ITEMS_FAILED = \"FETCH_ITEMS_FAILED\";\nconst SAVE_ITEM_STARTED = \"SAVE_ITEM_STARTED\";\nconst SAVE_ITEM_SUCCEEDED = \"SAVE_ITEM_SUCCEEDED\";\nconst SAVE_ITEM_SUCCEEDED_OFFLINE = \"SAVE_ITEM_SUCCEEDED_OFFLINE\";\nconst SAVE_ITEM_FAILED = \"SAVE_ITEM_FAILED\";\nconst DELETE_ITEM_STARTED = \"DELETE_ITEM_STARTED\";\nconst DELETE_ITEM_SUCCEEDED = \"DELETE_ITEM_SUCCEEDED\";\nconst DELETE_ITEM_FAILED = \"DELETE_ITEM_FAILED\";\n\nconst reducer = (state, {\n  type,\n  payload\n}) => {\n  // @ts-ignore\n  if (type === FETCH_ITEMS_STARTED) {\n    return { ...state,\n      fetching: true,\n      fetchingError: null\n    };\n  } else if (type === FETCH_ITEMS_SUCCEEDED) {\n    return { ...state,\n      beauties: payload.beauties,\n      fetching: false\n    };\n  } else if (type === FETCH_ITEMS_FAILED) {\n    return { ...state,\n      fetchingError: payload.error,\n      fetching: false\n    };\n  } else if (type === SAVE_ITEM_STARTED) {\n    return { ...state,\n      savingError: null,\n      saving: true\n    };\n  } else if (type === SAVE_ITEM_SUCCEEDED) {\n    const beauties = [...(state.beauties || [])];\n    const beauty = payload.beauty;\n\n    if (beauty._id !== undefined) {\n      log(\"BEAUTY in BeautyProvider: \" + JSON.stringify(beauty));\n      const index = beauties.findIndex(it => it._id === beauty._id);\n\n      if (index === -1) {\n        beauties.splice(0, 0, beauty);\n      } else {\n        beauties[index] = beauty;\n      }\n\n      return { ...state,\n        beauties,\n        saving: false\n      };\n    }\n\n    {\n      const beauties = [...(state.beauties || [])];\n      const beauty = payload.beauty;\n      const index = beauties.findIndex(it => it._id === beauty._id);\n\n      if (index === -1) {\n        beauties.splice(0, 0, beauty);\n      } else {\n        beauties[index] = beauty;\n      }\n\n      return { ...state,\n        beauties,\n        saving: false\n      };\n    }\n  } else if (type === SAVE_ITEM_SUCCEEDED_OFFLINE) {\n    {\n      const beauties = [...(state.beauties || [])];\n      const beauty = payload.beauty;\n      const index = beauties.findIndex(it => it._id === beauty._id);\n\n      if (index === -1) {\n        beauties.splice(0, 0, beauty);\n      } else {\n        beauties[index] = beauty;\n      }\n\n      return { ...state,\n        beauties,\n        saving: false\n      };\n    }\n  } else if (type === SAVE_ITEM_FAILED) {\n    return { ...state,\n      savingError: payload.error,\n      saving: false\n    };\n  } else if (type === DELETE_ITEM_STARTED) {\n    return { ...state,\n      deletingError: null,\n      deleting: true\n    };\n  } else if (type === DELETE_ITEM_SUCCEEDED) {\n    {\n      const beauties = [...(state.beauties || [])];\n      const beauty = payload.beauty;\n      const index = beauties.findIndex(it => it._id === beauty._id);\n      beauties.splice(index, 1);\n      return { ...state,\n        beauties,\n        deleting: false\n      };\n    }\n  } else if (type === DELETE_ITEM_FAILED) {\n    return { ...state,\n      deletingError: payload.error,\n      deleting: false\n    };\n  } else {\n    return state;\n  }\n};\n\nexport const BeautyContext = React.createContext(initialState);\nexport const BeautyProvider = ({\n  children\n}) => {\n  const {\n    token\n  } = useContext(AuthContext);\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const {\n    beauties,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    deleting\n  } = state;\n  useEffect(getBeautiesEffect, [token]);\n  useEffect(wsEffect, [token]);\n  const saveBeauty = useCallback(saveBeautyCallback, [token]);\n  const deleteBeauty = useCallback(deleteBeautyCallback, [token]);\n  const updateServer = useCallback(updateServerCallback, [token]);\n  const value = {\n    beauties,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    saveBeauty,\n    deleting,\n    deleteBeauty,\n    updateServer\n  };\n  log(\"returns\");\n  return /*#__PURE__*/React.createElement(BeautyContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 12\n    }\n  }, children);\n\n  function getBeautiesEffect() {\n    let canceled = false;\n    fetchBeauties();\n    return () => {\n      canceled = true;\n    };\n\n    async function fetchBeauties() {\n      if (!(token === null || token === void 0 ? void 0 : token.trim())) {\n        return;\n      }\n\n      try {\n        log(\"fetchBeauties started\");\n        dispatch({\n          type: FETCH_ITEMS_STARTED\n        });\n        const beauties = await getBeauties(token);\n        log(\"fetchBeauties succeeded\");\n\n        if (!canceled) {\n          dispatch({\n            type: FETCH_ITEMS_SUCCEEDED,\n            payload: {\n              beauties\n            }\n          });\n        }\n      } catch (error) {\n        //if there's no network, grab cartes from local storage\n        const allKeys = Storage.keys();\n        console.log(allKeys);\n        let promisedBeauties;\n        var i;\n        promisedBeauties = await allKeys.then(function (allKeys) {\n          // local storage also contains the login token, therefore we must get only beauty objects\n          const promises = [];\n\n          for (i = 0; i < allKeys.keys.length; i++) {\n            const promiseBeauty = Storage.get({\n              key: allKeys.keys[i]\n            });\n            promises.push(promiseBeauty);\n          }\n\n          return promises;\n        });\n        const allBeauties = [];\n\n        for (i = 0; i < promisedBeauties.length; i++) {\n          const promise = promisedBeauties[i];\n          const prod = await promise.then(function (it) {\n            var object;\n\n            try {\n              object = JSON.parse(it.value);\n            } catch (e) {\n              return null;\n            }\n\n            console.log(typeof object);\n            console.log(object);\n\n            if (object.status !== 2) {\n              return object;\n            }\n\n            return null;\n          });\n\n          if (prod != null) {\n            allBeauties.push(prod);\n          }\n        }\n\n        const beauties = allBeauties;\n        dispatch({\n          type: FETCH_ITEMS_SUCCEEDED,\n          payload: {\n            beauties: beauties\n          }\n        }); // log(\"fetchBeauties failed\");\n        // let realKeys: string[] = [];\n        // await Storage.keys().then( (keys)  => {\n        //     return keys.keys.forEach(function (value) {\n        //         if (value !== \"user\")\n        //             realKeys.push(value);\n        //     })\n        // });\n        //\n        // let values: string[] = [];\n        // for (const key1 of realKeys) {\n        //     await Storage.get({key: key1}).then((value)=>{\n        //         // @ts-ignore\n        //         values.push(value.value);\n        //     })\n        // }\n        // const beauties: BeautyProps[] = [];\n        // for(const value of values){\n        //     var beauty = JSON.parse(value);\n        //     beauties.push(beauty);\n        // }\n        // log(beauties);\n        // if (!canceled) {\n        //     dispatch({type: FETCH_ITEMS_SUCCEEDED, payload: {beauties}});\n        // }\n      }\n    }\n  }\n\n  function wsEffect() {\n    let canceled = false;\n    log('wsEffect - connecting');\n    let closeWebSocket;\n\n    if (token === null || token === void 0 ? void 0 : token.trim()) {\n      closeWebSocket = newWebSocket(token, message => {\n        if (canceled) {\n          return;\n        }\n\n        const {\n          type,\n          payload: beauty\n        } = message;\n        log(`ws message, beauty ${type} ${beauty._id}`);\n\n        if (type === 'created' || type === 'updated') {//dispatch({type: SAVE_ITEM_SUCCEEDED, payload: {carte} });\n        }\n      });\n      return () => {\n        var _closeWebSocket;\n\n        log('wsEffect - disconnecting');\n        canceled = true;\n        (_closeWebSocket = closeWebSocket) === null || _closeWebSocket === void 0 ? void 0 : _closeWebSocket();\n      };\n    }\n  }\n\n  async function saveBeautyCallback(beauty, connected) {\n    try {\n      console.log(\"E conectat? \");\n      console.log(connected);\n\n      if (!connected) {\n        throw new Error();\n      }\n\n      log(\"saveBeauty started\");\n      dispatch({\n        type: SAVE_ITEM_STARTED\n      });\n      const savedBeauty = await (beauty._id ? updateBeauties(token, beauty) : createBeauties(token, beauty));\n      log(\"saveBeauty succeeded\");\n      dispatch({\n        type: SAVE_ITEM_SUCCEEDED,\n        payload: {\n          beauty: savedBeauty\n        }\n      });\n    } catch (error) {\n      log(\"saveBeauty failed with error: \", error);\n\n      if (beauty._id === undefined) {\n        beauty._id = generateRandomID();\n        beauty.status = 1;\n        alert(\"Beauty saved locally!!!\");\n      } else {\n        beauty.status = 2;\n        alert(\"Beauty updated locally!!!\");\n      }\n\n      await Storage.set({\n        key: beauty._id,\n        value: JSON.stringify(beauty)\n      });\n      dispatch({\n        type: SAVE_ITEM_SUCCEEDED_OFFLINE,\n        payload: {\n          beauty: beauty\n        }\n      }); //dispatch({ type: SAVE_ITEM_FAILED, payload: { error } });\n    }\n  }\n\n  async function deleteBeautyCallback(beauty, connected) {\n    try {\n      if (!connected) {\n        throw new Error();\n      }\n\n      dispatch({\n        type: DELETE_ITEM_STARTED\n      });\n      const deletedProduct = await eraseBeauty(token, beauty);\n      console.log(deletedProduct);\n      await Storage.remove({\n        key: beauty._id\n      });\n      dispatch({\n        type: DELETE_ITEM_SUCCEEDED,\n        payload: {\n          beauty: beauty\n        }\n      });\n    } catch (error) {\n      beauty.status = 3;\n      await Storage.set({\n        key: JSON.stringify(beauty._id),\n        value: JSON.stringify(beauty)\n      });\n      alert(\"Product deleted locally!!!\");\n      dispatch({\n        type: DELETE_ITEM_SUCCEEDED,\n        payload: {\n          beauty: beauty\n        }\n      });\n    }\n  }\n\n  async function updateServerCallback() {\n    //grab beauties from local storage\n    const allKeys = Storage.keys();\n    let promisedBeauties;\n    var i;\n    promisedBeauties = await allKeys.then(function (allKeys) {\n      const promises = [];\n\n      for (i = 0; i < allKeys.keys.length; i++) {\n        const promiseBeauty = Storage.get({\n          key: allKeys.keys[i]\n        });\n        promises.push(promiseBeauty);\n      }\n\n      return promises;\n    });\n\n    for (i = 0; i < promisedBeauties.length; i++) {\n      const promise = promisedBeauties[i];\n      const beauty = await promise.then(function (it) {\n        var object;\n\n        try {\n          object = JSON.parse(it.value);\n        } catch (e) {\n          return null;\n        }\n\n        return object;\n      });\n\n      if (beauty !== null) {\n        //beauty has to be added\n        if (beauty.status === 1) {\n          dispatch({\n            type: DELETE_ITEM_SUCCEEDED,\n            payload: {\n              beauty: beauty\n            }\n          });\n          await Storage.remove({\n            key: beauty._id\n          });\n          const oldBeauty = beauty;\n          delete oldBeauty._id;\n          oldBeauty.status = 0;\n          const newBeauty = await createBeauties(token, oldBeauty);\n          dispatch({\n            type: SAVE_ITEM_SUCCEEDED,\n            payload: {\n              beauty: newBeauty\n            }\n          });\n          await Storage.set({\n            key: JSON.stringify(newBeauty._id),\n            value: JSON.stringify(newBeauty)\n          });\n        } //Beauty has to be updated\n        else if (beauty.status === 2) {\n            beauty.status = 0;\n            const newBeauty = await updateBeauties(token, beauty);\n            dispatch({\n              type: SAVE_ITEM_SUCCEEDED,\n              payload: {\n                beauty: newBeauty\n              }\n            });\n            await Storage.set({\n              key: JSON.stringify(newBeauty._id),\n              value: JSON.stringify(newBeauty)\n            });\n          } //carte has to be deleted\n          else if (beauty.status === 3) {\n              beauty.status = 0;\n              await eraseBeauty(token, beauty);\n              await Storage.remove({\n                key: beauty._id\n              });\n            }\n      }\n    }\n  } //generates random id for storing carte locally\n\n\n  function generateRandomID() {\n    return \"_\" + Math.random().toString(36).substr(2, 9);\n  }\n};","map":{"version":3,"sources":["C:/Users/Anisoara Bacrau/Desktop/an3/PDM/ionic/PDM-IonicApp/src/todo/BeautyProvider.tsx"],"names":["React","useCallback","useContext","useEffect","useReducer","getLogger","createBeauties","getBeauties","newWebSocket","updateBeauties","eraseBeauty","AuthContext","Plugins","Storage","log","initialState","fetching","saving","deleting","oldBeauty","undefined","FETCH_ITEMS_STARTED","FETCH_ITEMS_SUCCEEDED","FETCH_ITEMS_FAILED","SAVE_ITEM_STARTED","SAVE_ITEM_SUCCEEDED","SAVE_ITEM_SUCCEEDED_OFFLINE","SAVE_ITEM_FAILED","DELETE_ITEM_STARTED","DELETE_ITEM_SUCCEEDED","DELETE_ITEM_FAILED","reducer","state","type","payload","fetchingError","beauties","error","savingError","beauty","_id","JSON","stringify","index","findIndex","it","splice","deletingError","BeautyContext","createContext","BeautyProvider","children","token","dispatch","getBeautiesEffect","wsEffect","saveBeauty","saveBeautyCallback","deleteBeauty","deleteBeautyCallback","updateServer","updateServerCallback","value","canceled","fetchBeauties","trim","allKeys","keys","console","promisedBeauties","i","then","promises","length","promiseBeauty","get","key","push","allBeauties","promise","prod","object","parse","e","status","closeWebSocket","message","connected","Error","savedBeauty","generateRandomID","alert","set","deletedProduct","remove","newBeauty","Math","random","toString","substr"],"mappings":"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","sourcesContent":["import React, { useCallback, useContext, useEffect, useReducer } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { getLogger } from \"../core\";\r\nimport { BeautyProps } from \"./BeautyProps\";\r\nimport {\r\n    createBeauties,\r\n    getBeauties,\r\n    newWebSocket,\r\n    updateBeauties,\r\n    eraseBeauty,\r\n} from \"./beautyApi\";\r\nimport {AuthContext} from \"../auth\";\r\n\r\nimport { Plugins } from \"@capacitor/core\"\r\nconst { Storage } = Plugins;\r\n\r\nconst log = getLogger(\"BeautyProvider\");\r\n\r\ntype SaveBeautyFn = (beauty: BeautyProps,connected: boolean) => Promise<any>;\r\ntype DeleteBeautyFn = (beauty: BeautyProps, connected: boolean) => Promise<any>;\r\ntype UpdateServerFn = () => Promise<any>;\r\ntype ServerBeauty = (id: string, version: number) => Promise<any>;\r\n\r\nexport interface BeautyState {\r\n    beauties?: BeautyProps[];\r\n    oldBeauty?: BeautyProps;\r\n    fetching: boolean;\r\n    fetchingError?: Error | null;\r\n    saving: boolean;\r\n    deleting: boolean;\r\n    savingError?: Error | null;\r\n    deletingError?: Error | null;\r\n    saveBeauty?: SaveBeautyFn;\r\n    deleteBeauty?: DeleteBeautyFn;\r\n    updateServer?: UpdateServerFn,\r\n    getServerBeauty?: ServerBeauty,\r\n}\r\n\r\ninterface ActionProps {\r\n    type: string;\r\n    payload?: any;\r\n}\r\n\r\nconst initialState: BeautyState = {\r\n    fetching: false,\r\n    saving: false,\r\n    deleting: false,\r\n    oldBeauty: undefined,\r\n};\r\n\r\nconst FETCH_ITEMS_STARTED = \"FETCH_ITEMS_STARTED\";\r\nconst FETCH_ITEMS_SUCCEEDED = \"FETCH_ITEMS_SUCCEEDED\";\r\nconst FETCH_ITEMS_FAILED = \"FETCH_ITEMS_FAILED\";\r\n\r\nconst SAVE_ITEM_STARTED = \"SAVE_ITEM_STARTED\";\r\nconst SAVE_ITEM_SUCCEEDED = \"SAVE_ITEM_SUCCEEDED\";\r\nconst SAVE_ITEM_SUCCEEDED_OFFLINE = \"SAVE_ITEM_SUCCEEDED_OFFLINE\";\r\nconst SAVE_ITEM_FAILED = \"SAVE_ITEM_FAILED\";\r\n\r\nconst DELETE_ITEM_STARTED = \"DELETE_ITEM_STARTED\";\r\nconst DELETE_ITEM_SUCCEEDED = \"DELETE_ITEM_SUCCEEDED\";\r\nconst DELETE_ITEM_FAILED = \"DELETE_ITEM_FAILED\";\r\n\r\nconst reducer: (state: BeautyState, action: ActionProps) => BeautyState = (\r\n    state,\r\n    { type, payload }\r\n) => {\r\n    // @ts-ignore\r\n    if (type === FETCH_ITEMS_STARTED) {\r\n        return {...state, fetching: true, fetchingError: null};\r\n    } else if (type === FETCH_ITEMS_SUCCEEDED) {\r\n        return {...state, beauties: payload.beauties, fetching: false};\r\n    } else if (type === FETCH_ITEMS_FAILED) {\r\n        return {...state, fetchingError: payload.error, fetching: false};\r\n    } else if (type === SAVE_ITEM_STARTED) {\r\n        return {...state, savingError: null, saving: true};\r\n    } else if (type === SAVE_ITEM_SUCCEEDED) {\r\n        const beauties = [...(state.beauties || [])];\r\n        const beauty = payload.beauty;\r\n        if (beauty._id !== undefined) {\r\n            log(\"BEAUTY in BeautyProvider: \" + JSON.stringify(beauty));\r\n            const index = beauties.findIndex((it) => it._id === beauty._id);\r\n            if (index === -1) {\r\n                beauties.splice(0, 0, beauty);\r\n            } else {\r\n                beauties[index] = beauty;\r\n            }\r\n            return {...state, beauties, saving: false};\r\n        }\r\n        {\r\n            const beauties = [...(state.beauties || [])];\r\n            const beauty = payload.beauty;\r\n            const index = beauties.findIndex((it) => it._id === beauty._id);\r\n            if (index === -1) {\r\n                beauties.splice(0, 0, beauty);\r\n            } else {\r\n                beauties[index] = beauty;\r\n            }\r\n            return {...state, beauties, saving: false};\r\n        }\r\n    } else if (type === SAVE_ITEM_SUCCEEDED_OFFLINE) {\r\n        {\r\n            const beauties = [...(state.beauties || [])];\r\n            const beauty = payload.beauty;\r\n            const index = beauties.findIndex((it) => it._id === beauty._id);\r\n            if (index === -1) {\r\n                beauties.splice(0, 0, beauty);\r\n            } else {\r\n                beauties[index] = beauty;\r\n            }\r\n            return {...state, beauties, saving: false};\r\n        }\r\n    } else if (type === SAVE_ITEM_FAILED) {\r\n        return {...state, savingError: payload.error, saving: false};\r\n    } else if (type === DELETE_ITEM_STARTED) {\r\n        return {...state, deletingError: null, deleting: true};\r\n    } else if (type === DELETE_ITEM_SUCCEEDED) {\r\n        {\r\n            const beauties = [...(state.beauties || [])];\r\n            const beauty = payload.beauty;\r\n            const index = beauties.findIndex((it) => it._id === beauty._id);\r\n            beauties.splice(index, 1);\r\n            return {...state, beauties, deleting: false};\r\n        }\r\n    } else if (type === DELETE_ITEM_FAILED) {\r\n        return {...state, deletingError: payload.error, deleting: false};\r\n    } else {\r\n        return state;\r\n    }\r\n};\r\n\r\nexport const BeautyContext = React.createContext<BeautyState>(initialState);\r\n\r\ninterface BeautyProviderProps {\r\n    children: PropTypes.ReactNodeLike;\r\n}\r\n\r\nexport const BeautyProvider: React.FC<BeautyProviderProps> = ({ children }) => {\r\n    const { token } = useContext(AuthContext);\r\n    const [state, dispatch] = useReducer(reducer, initialState);\r\n    const {\r\n        beauties,\r\n        fetching,\r\n        fetchingError,\r\n        saving,\r\n        savingError,\r\n        deleting,\r\n    } = state;\r\n\r\n\r\n    useEffect(getBeautiesEffect, [token]);\r\n    useEffect(wsEffect, [token]);\r\n\r\n    const saveBeauty = useCallback<SaveBeautyFn>(saveBeautyCallback, [token]);\r\n    const deleteBeauty = useCallback<DeleteBeautyFn>(deleteBeautyCallback, [token]);\r\n    const updateServer = useCallback<UpdateServerFn>(updateServerCallback, [token]);\r\n\r\n    const value = {\r\n        beauties,\r\n        fetching,\r\n        fetchingError,\r\n        saving,\r\n        savingError,\r\n        saveBeauty,\r\n        deleting,\r\n        deleteBeauty,\r\n        updateServer,\r\n    };\r\n\r\n    log(\"returns\");\r\n    return <BeautyContext.Provider value={value}>{children}</BeautyContext.Provider>;\r\n\r\n    function getBeautiesEffect() {\r\n        let canceled = false;\r\n        fetchBeauties();\r\n        return () => {\r\n            canceled = true;\r\n        };\r\n\r\n        async function fetchBeauties() {\r\n            if (!token?.trim()) {\r\n                return;\r\n            }\r\n            try {\r\n                log(\"fetchBeauties started\");\r\n                dispatch({ type: FETCH_ITEMS_STARTED });\r\n                const beauties = await getBeauties(token);\r\n                log(\"fetchBeauties succeeded\");\r\n                if (!canceled) {\r\n                    dispatch({ type: FETCH_ITEMS_SUCCEEDED, payload: { beauties } });\r\n                }\r\n            } catch (error) {\r\n                //if there's no network, grab cartes from local storage\r\n                const allKeys = Storage.keys();\r\n                console.log(allKeys);\r\n                let promisedBeauties;\r\n                var i;\r\n                promisedBeauties = await allKeys.then(function (allKeys) {\r\n                    // local storage also contains the login token, therefore we must get only beauty objects\r\n                    const promises = [];\r\n                    for (i = 0; i < allKeys.keys.length; i++) {\r\n                        const promiseBeauty = Storage.get({ key: allKeys.keys[i] });\r\n                        promises.push(promiseBeauty);\r\n                    }\r\n                    return promises;\r\n                });\r\n\r\n                const allBeauties = [];\r\n                for (i = 0; i < promisedBeauties.length; i++) {\r\n                    const promise = promisedBeauties[i];\r\n                    const prod = await promise.then(function (it) {\r\n                        var object;\r\n                        try {\r\n                            object = JSON.parse(it.value!);\r\n                        } catch (e) {\r\n                            return null;\r\n                        }\r\n                        console.log(typeof object);\r\n                        console.log(object);\r\n                        if (object.status !== 2) {\r\n                            return object;\r\n                        }\r\n                        return null;\r\n                    });\r\n                    if (prod != null) {\r\n                        allBeauties.push(prod);\r\n                    }\r\n                }\r\n                const beauties = allBeauties;\r\n                dispatch({ type: FETCH_ITEMS_SUCCEEDED, payload: { beauties: beauties } });\r\n                // log(\"fetchBeauties failed\");\r\n                // let realKeys: string[] = [];\r\n                // await Storage.keys().then( (keys)  => {\r\n                //     return keys.keys.forEach(function (value) {\r\n                //         if (value !== \"user\")\r\n                //             realKeys.push(value);\r\n                //     })\r\n                // });\r\n                //\r\n                // let values: string[] = [];\r\n                // for (const key1 of realKeys) {\r\n                //     await Storage.get({key: key1}).then((value)=>{\r\n                //         // @ts-ignore\r\n                //         values.push(value.value);\r\n                //     })\r\n                // }\r\n                // const beauties: BeautyProps[] = [];\r\n                // for(const value of values){\r\n                //     var beauty = JSON.parse(value);\r\n                //     beauties.push(beauty);\r\n                // }\r\n                // log(beauties);\r\n                // if (!canceled) {\r\n                //     dispatch({type: FETCH_ITEMS_SUCCEEDED, payload: {beauties}});\r\n                // }\r\n            }\r\n        }\r\n    }\r\n\r\n    function wsEffect() {\r\n        let canceled = false;\r\n        log('wsEffect - connecting');\r\n        let closeWebSocket: () => void;\r\n        if(token?.trim()) {\r\n            closeWebSocket = newWebSocket(token,(message) => {\r\n                if (canceled) {\r\n                    return;\r\n                }\r\n                const { type, payload: beauty } = message;\r\n                log(`ws message, beauty ${type} ${beauty._id}`);\r\n                if (type === 'created' || type === 'updated') {\r\n                    //dispatch({type: SAVE_ITEM_SUCCEEDED, payload: {carte} });\r\n                }\r\n            });\r\n            return () => {\r\n                log('wsEffect - disconnecting');\r\n                canceled = true;\r\n                closeWebSocket?.();\r\n            }\r\n        }\r\n    }\r\n\r\n    async function saveBeautyCallback(beauty: BeautyProps,connected: boolean) {\r\n        try {\r\n            console.log(\"E conectat? \")\r\n            console.log(connected)\r\n            if (!connected) {\r\n                throw new Error();\r\n            }\r\n\r\n            log(\"saveBeauty started\");\r\n            dispatch({ type: SAVE_ITEM_STARTED });\r\n            const savedBeauty = await (beauty._id\r\n                ? updateBeauties(token, beauty)\r\n                : createBeauties(token, beauty));\r\n            log(\"saveBeauty succeeded\");\r\n            dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { beauty: savedBeauty } });\r\n        } catch (error) {\r\n            log(\"saveBeauty failed with error: \", error);\r\n\r\n            if (beauty._id === undefined) {\r\n                beauty._id = generateRandomID()\r\n                beauty.status = 1;\r\n                alert(\"Beauty saved locally!!!\");\r\n            } else {\r\n                beauty.status = 2;\r\n                alert(\"Beauty updated locally!!!\");\r\n            }\r\n            await Storage.set({\r\n                key: beauty._id,\r\n                value: JSON.stringify(beauty),\r\n            });\r\n\r\n            dispatch({ type: SAVE_ITEM_SUCCEEDED_OFFLINE, payload: { beauty: beauty } });\r\n            //dispatch({ type: SAVE_ITEM_FAILED, payload: { error } });\r\n        }\r\n    }\r\n\r\n    async function deleteBeautyCallback(beauty: BeautyProps, connected: boolean) {\r\n        try {\r\n            if (!connected) {\r\n                throw new Error();\r\n            }\r\n            dispatch({ type: DELETE_ITEM_STARTED });\r\n            const deletedProduct = await eraseBeauty(token, beauty);\r\n            console.log(deletedProduct);\r\n            await Storage.remove({ key: beauty._id! });\r\n            dispatch({ type: DELETE_ITEM_SUCCEEDED, payload: { beauty: beauty } });\r\n        }\r\n        catch (error) {\r\n            beauty.status = 3;\r\n            await Storage.set({\r\n                key: JSON.stringify(beauty._id),\r\n                value: JSON.stringify(beauty),\r\n            });\r\n            alert(\"Product deleted locally!!!\");\r\n            dispatch({ type: DELETE_ITEM_SUCCEEDED, payload: { beauty: beauty } });\r\n        }\r\n    }\r\n\r\n    async function updateServerCallback() {\r\n        //grab beauties from local storage\r\n        const allKeys = Storage.keys();\r\n        let promisedBeauties;\r\n        var i;\r\n\r\n        promisedBeauties = await allKeys.then(function (allKeys) {\r\n            const promises = [];\r\n            for (i = 0; i < allKeys.keys.length; i++) {\r\n                const promiseBeauty = Storage.get({ key: allKeys.keys[i] });\r\n                promises.push(promiseBeauty);\r\n            }\r\n            return promises;\r\n        });\r\n\r\n        for (i = 0; i < promisedBeauties.length; i++) {\r\n            const promise = promisedBeauties[i];\r\n            const beauty = await promise.then(function (it) {\r\n                var object;\r\n                try {\r\n                    object = JSON.parse(it.value!);\r\n                } catch (e) {\r\n                    return null;\r\n                }\r\n                return object;\r\n            });\r\n            if (beauty !== null) {\r\n                //beauty has to be added\r\n                if (beauty.status === 1) {\r\n                    dispatch({ type: DELETE_ITEM_SUCCEEDED, payload: { beauty: beauty } });\r\n                    await Storage.remove({ key: beauty._id });\r\n                    const oldBeauty = beauty;\r\n                    delete oldBeauty._id;\r\n                    oldBeauty.status = 0;\r\n                    const newBeauty = await createBeauties(token, oldBeauty);\r\n                    dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { beauty: newBeauty } });\r\n                    await Storage.set({\r\n                        key: JSON.stringify(newBeauty._id),\r\n                        value: JSON.stringify(newBeauty),\r\n                    });\r\n                }\r\n                //Beauty has to be updated\r\n                else if (beauty.status === 2) {\r\n                    beauty.status = 0;\r\n                    const newBeauty = await updateBeauties(token, beauty);\r\n                    dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { beauty: newBeauty } });\r\n                    await Storage.set({\r\n                        key: JSON.stringify(newBeauty._id),\r\n                        value: JSON.stringify(newBeauty),\r\n                    });\r\n                }\r\n                //carte has to be deleted\r\n                else if (beauty.status === 3) {\r\n                    beauty.status = 0;\r\n                    await eraseBeauty(token, beauty);\r\n                    await Storage.remove({ key: beauty._id });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //generates random id for storing carte locally\r\n    function generateRandomID() {\r\n        return \"_\" + Math.random().toString(36).substr(2, 9);\r\n    }\r\n\r\n};\r\n"]},"metadata":{},"sourceType":"module"}