{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Anisoara Bacrau\\\\Desktop\\\\an3\\\\PDM\\\\ionic\\\\PDM-IonicApp\\\\src\\\\todo\\\\BeautyProvider.tsx\";\nimport React, { useCallback, useContext, useEffect, useReducer } from \"react\";\nimport { getLogger } from \"../core\";\nimport { createBeauties, getBeauties, newWebSocket, updateBeauties, eraseBeauty } from \"./beautyApi\";\nimport { AuthContext } from \"../auth\";\nimport { Plugins } from \"@capacitor/core\";\nconst {\n  Storage\n} = Plugins;\nconst log = getLogger(\"BeautyProvider\");\nconst initialState = {\n  fetching: false,\n  saving: false,\n  deleting: false\n};\nconst FETCH_ITEMS_STARTED = \"FETCH_ITEMS_STARTED\";\nconst FETCH_ITEMS_SUCCEEDED = \"FETCH_ITEMS_SUCCEEDED\";\nconst FETCH_ITEMS_FAILED = \"FETCH_ITEMS_FAILED\";\nconst SAVE_ITEM_STARTED = \"SAVE_ITEM_STARTED\";\nconst SAVE_ITEM_SUCCEEDED = \"SAVE_ITEM_SUCCEEDED\";\nconst SAVE_ITEM_FAILED = \"SAVE_ITEM_FAILED\";\nconst DELETE_ITEM_STARTED = \"DELETE_ITEM_STARTED\";\nconst DELETE_ITEM_SUCCEEDED = \"DELETE_ITEM_SUCCEEDED\";\nconst DELETE_ITEM_FAILED = \"DELETE_ITEM_FAILED\";\n\nconst reducer = (state, {\n  type,\n  payload\n}) => {\n  switch (type) {\n    case FETCH_ITEMS_STARTED:\n      return { ...state,\n        fetching: true,\n        fetchingError: null\n      };\n\n    case FETCH_ITEMS_SUCCEEDED:\n      return { ...state,\n        beauties: payload.beauties,\n        fetching: false\n      };\n\n    case FETCH_ITEMS_FAILED:\n      return { ...state,\n        fetchingError: payload.error,\n        fetching: false\n      };\n\n    case SAVE_ITEM_STARTED:\n      return { ...state,\n        savingError: null,\n        saving: true\n      };\n\n    case SAVE_ITEM_SUCCEEDED:\n      const beauties = [...(state.beauties || [])];\n      const beauty = payload.beauty;\n\n      if (beauty != undefined) {\n        const index = beauties.findIndex(it => it._id === beauty._id);\n\n        if (index === -1) {\n          beauties.splice(0, 0, beauty);\n        } else {\n          beauties[index] = beauty;\n        }\n\n        return { ...state,\n          beauties,\n          saving: false\n        };\n      }\n\n    case SAVE_ITEM_FAILED:\n      return { ...state,\n        savingError: payload.error,\n        saving: false\n      };\n\n    case DELETE_ITEM_STARTED:\n      return { ...state,\n        deletingError: null,\n        deleting: true\n      };\n\n    case DELETE_ITEM_SUCCEEDED:\n      {\n        const beauties = [...(state.beauties || [])];\n        const beauty = payload.beauty;\n        const index = beauties.findIndex(it => it._id === beauty._id);\n        beauties.splice(index, 1);\n        return { ...state,\n          beauties,\n          deleting: false\n        };\n      }\n\n    case DELETE_ITEM_FAILED:\n      return { ...state,\n        deletingError: payload.error,\n        deleting: false\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport const BeautyContext = React.createContext(initialState);\nexport const BeautyProvider = ({\n  children\n}) => {\n  const {\n    token\n  } = useContext(AuthContext);\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const {\n    beauties,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    deleting\n  } = state;\n  useEffect(getBeautiesEffect, [token]);\n  useEffect(wsEffect, [token]);\n  const saveBeauty = useCallback(saveBeautyCallback, [token]);\n  const deleteBeauty = useCallback(deleteBeautyCallback, [token]);\n  const value = {\n    beauties,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    saveBeauty,\n    deleting,\n    deleteBeauty\n  };\n  log(\"returns\");\n  return /*#__PURE__*/React.createElement(BeautyContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 12\n    }\n  }, children);\n\n  function getBeautiesEffect() {\n    let canceled = false;\n    fetchBeauties();\n    return () => {\n      canceled = true;\n    };\n\n    async function fetchBeauties() {\n      if (!(token === null || token === void 0 ? void 0 : token.trim())) {\n        return;\n      }\n\n      try {\n        log(\"fetchBeauties started\");\n        dispatch({\n          type: FETCH_ITEMS_STARTED\n        });\n        const beauties = await getBeauties(token);\n        log(\"fetchBeauties succeeded\");\n\n        if (!canceled) {\n          dispatch({\n            type: FETCH_ITEMS_SUCCEEDED,\n            payload: {\n              beauties\n            }\n          });\n        }\n      } catch (error) {\n        log(\"fetchBeauties failed\");\n        let realKeys = [];\n        await Storage.keys().then(keys => {\n          return keys.keys.forEach(function (value) {\n            if (value !== \"user\") realKeys.push(value);\n          });\n        });\n        let values = [];\n\n        for (const key1 of realKeys) {\n          await Storage.get({\n            key: key1\n          }).then(value => {\n            // @ts-ignore\n            values.push(value.value);\n          });\n        }\n\n        const beauties = [];\n\n        for (const value of values) {\n          var beauty = JSON.parse(value);\n          beauties.push(beauty);\n        }\n\n        log(beauties);\n\n        if (!canceled) {\n          dispatch({\n            type: FETCH_ITEMS_SUCCEEDED,\n            payload: {\n              beauties\n            }\n          });\n        }\n      }\n    }\n  }\n\n  async function saveBeautyCallback(beauty) {\n    try {\n      log(\"saveBeauty started\");\n      dispatch({\n        type: SAVE_ITEM_STARTED\n      });\n      const savedBeauty = await (beauty._id ? updateBeauties(token, beauty) : createBeauties(token, beauty));\n      log(\"saveBeauty succeeded\");\n      dispatch({\n        type: SAVE_ITEM_SUCCEEDED,\n        payload: {\n          beauty: savedBeauty\n        }\n      });\n    } catch (error) {\n      log(\"saveBeauty failed\");\n      dispatch({\n        type: SAVE_ITEM_FAILED,\n        payload: {\n          error\n        }\n      });\n    }\n  }\n\n  async function deleteBeautyCallback(beauty) {\n    try {\n      log(\"delete started\");\n      dispatch({\n        type: DELETE_ITEM_STARTED\n      });\n      const deletedBeauty = await eraseBeauty(token, beauty);\n      log(\"delete succeeded\");\n      console.log(deletedBeauty);\n      dispatch({\n        type: DELETE_ITEM_SUCCEEDED,\n        payload: {\n          beauty: beauty\n        }\n      });\n    } catch (error) {\n      log(\"delete failed\");\n      dispatch({\n        type: DELETE_ITEM_FAILED,\n        payload: {\n          error\n        }\n      });\n    }\n  }\n\n  function wsEffect() {\n    let canceled = false;\n    log(\"wsEffect - connecting\");\n    let closeWebSocket;\n\n    if (token === null || token === void 0 ? void 0 : token.trim()) {\n      closeWebSocket = newWebSocket(token, message => {\n        if (canceled) {\n          return;\n        }\n\n        const {\n          type,\n          payload: carte\n        } = message;\n        log(`ws message, carte ${type}`);\n      });\n    }\n\n    return () => {\n      var _closeWebSocket;\n\n      log(\"wsEffect - disconnecting\");\n      canceled = true;\n      (_closeWebSocket = closeWebSocket) === null || _closeWebSocket === void 0 ? void 0 : _closeWebSocket();\n    };\n  }\n}; // import React, { useCallback, useEffect, useReducer, useContext } from 'react';\n// import PropTypes from 'prop-types';\n// import { getLogger } from '../core';\n// import { BeautyProps } from './BeautyProps';\n// import { createBeauties, getBeauties, updateBeauties, newWebSocket, eraseBeauty } from './beautyApi';\n//\n// const log = getLogger('BeautyProvider');\n//\n// type SaveItemFn = (item: BeautyProps) => Promise<any>;\n//\n// export interface ItemsState {\n//     items?: BeautyProps[],\n//     fetching: boolean,\n//     fetchingError?: Error | null,\n//     saving: boolean,\n//     savingError?: Error | null,\n//     saveItem?: SaveItemFn,\n// }\n//\n// interface ActionProps {\n//     type: string,\n//     payload?: any,\n// }\n//\n// const initialState: ItemsState = {\n//     fetching: false,\n//     saving: false,\n// };\n//\n// const FETCH_ITEMS_STARTED = 'FETCH_ITEMS_STARTED';\n// const FETCH_ITEMS_SUCCEEDED = 'FETCH_ITEMS_SUCCEEDED';\n// const FETCH_ITEMS_FAILED = 'FETCH_ITEMS_FAILED';\n// const SAVE_ITEM_STARTED = 'SAVE_ITEM_STARTED';\n// const SAVE_ITEM_SUCCEEDED = 'SAVE_ITEM_SUCCEEDED';\n// const SAVE_ITEM_FAILED = 'SAVE_ITEM_FAILED';\n//\n// const reducer: (state: ItemsState, action: ActionProps) => ItemsState =\n//     (state, { type, payload }) => {\n//         switch(type) {\n//             case FETCH_ITEMS_STARTED:\n//                 return { ...state, fetching: true, fetchingError: null };\n//             case FETCH_ITEMS_SUCCEEDED:\n//                 return { ...state, items: payload.items, fetching: false };\n//             case FETCH_ITEMS_FAILED:\n//                 return { ...state, fetchingError: payload.error, fetching: false };\n//             case SAVE_ITEM_STARTED:\n//                 return { ...state, savingError: null, saving: true };\n//             case SAVE_ITEM_SUCCEEDED:\n//                 const items = [...(state.items || [])];\n//                 const item = payload.item;\n//                 const index = items.findIndex(it => it.id === item.id);\n//                 if (index === -1) {\n//                     items.splice(0, 0, item);\n//                 } else {\n//                     items[index] = item;\n//                 }\n//                 return { ...state,  items, saving: false };\n//             case SAVE_ITEM_FAILED:\n//                 return { ...state, savingError: payload.error, saving: false };\n//             default:\n//                 return state;\n//         }\n//     };\n//\n// export const ItemContext = React.createContext<ItemsState>(initialState);\n//\n// interface ItemProviderProps {\n//     children: PropTypes.ReactNodeLike,\n// }\n//\n// export const BeautyProvider: React.FC<ItemProviderProps> = ({ children }) => {\n//     const [state, dispatch] = useReducer(reducer, initialState);\n//     const { items, fetching, fetchingError, saving, savingError } = state;\n//     useEffect(getItemsEffect, []);\n//     const saveItem = useCallback<SaveItemFn>(saveItemCallback, []);\n//     const value = { items, fetching, fetchingError, saving, savingError, saveItem };\n//     log('returns');\n//     return (\n//         <ItemContext.Provider value={value}>\n//             {children}\n//         </ItemContext.Provider>\n//     );\n//\n//     function getItemsEffect() {\n//         let canceled = false;\n//         fetchItems();\n//         return () => {\n//             canceled = true;\n//         }\n//\n//         async function fetchItems() {\n//             try {\n//                 log('fetchItems started');\n//                 dispatch({ type: FETCH_ITEMS_STARTED });\n//                 const items = await getItems();\n//                 log('fetchItems succeeded');\n//                 if (!canceled) {\n//                     dispatch({ type: FETCH_ITEMS_SUCCEEDED, payload: { items } });\n//                 }\n//             } catch (error) {\n//                 log('fetchItems failed');\n//                 dispatch({ type: FETCH_ITEMS_FAILED, payload: { error } });\n//             }\n//         }\n//     }\n//\n//     async function saveItemCallback(item: BeautyProps) {\n//         try {\n//             log('saveItem started');\n//             dispatch({ type: SAVE_ITEM_STARTED });\n//             const savedItem = await (item.id ? updateItem(item) : createItem(item));\n//             log('saveItem succeeded');\n//             dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { item: savedItem } });\n//         } catch (error) {\n//             log('saveItem failed');\n//             dispatch({ type: SAVE_ITEM_FAILED, payload: { error } });\n//         }\n//     }\n// };","map":{"version":3,"sources":["C:/Users/Anisoara Bacrau/Desktop/an3/PDM/ionic/PDM-IonicApp/src/todo/BeautyProvider.tsx"],"names":["React","useCallback","useContext","useEffect","useReducer","getLogger","createBeauties","getBeauties","newWebSocket","updateBeauties","eraseBeauty","AuthContext","Plugins","Storage","log","initialState","fetching","saving","deleting","FETCH_ITEMS_STARTED","FETCH_ITEMS_SUCCEEDED","FETCH_ITEMS_FAILED","SAVE_ITEM_STARTED","SAVE_ITEM_SUCCEEDED","SAVE_ITEM_FAILED","DELETE_ITEM_STARTED","DELETE_ITEM_SUCCEEDED","DELETE_ITEM_FAILED","reducer","state","type","payload","fetchingError","beauties","error","savingError","beauty","undefined","index","findIndex","it","_id","splice","deletingError","BeautyContext","createContext","BeautyProvider","children","token","dispatch","getBeautiesEffect","wsEffect","saveBeauty","saveBeautyCallback","deleteBeauty","deleteBeautyCallback","value","canceled","fetchBeauties","trim","realKeys","keys","then","forEach","push","values","key1","get","key","JSON","parse","savedBeauty","deletedBeauty","console","closeWebSocket","message","carte"],"mappings":"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H,KAPD,CAOE,OAAOF,KAAP,EAAc;AACZpB,MAAAA,GAAG,CAAC,eAAD,CAAH;AACAmC,MAAAA,QAAQ,CAAC;AAAEnB,QAAAA,IAAI,EAAEH,kBAAR;AAA4BI,QAAAA,OAAO,EAAE;AAAEG,UAAAA;AAAF;AAArC,OAAD,CAAR;AACH;AACJ;;AAED,WAASiB,QAAT,GAAoB;AAChB,QAAIM,QAAQ,GAAG,KAAf;AACA3C,IAAAA,GAAG,CAAC,uBAAD,CAAH;AACA,QAAI4D,cAAJ;;AACA,QAAI1B,KAAJ,aAAIA,KAAJ,uBAAIA,KAAK,CAAEW,IAAP,EAAJ,EAAmB;AACfe,MAAAA,cAAc,GAAGlE,YAAY,CAACwC,KAAD,EAAS2B,OAAD,IAAa;AAC9C,YAAIlB,QAAJ,EAAc;AACV;AACH;;AACD,cAAM;AAAE3B,UAAAA,IAAF;AAAQC,UAAAA,OAAO,EAAE6C;AAAjB,YAA2BD,OAAjC;AACA7D,QAAAA,GAAG,CAAE,qBAAoBgB,IAAK,EAA3B,CAAH;AAEH,OAP4B,CAA7B;AAQH;;AACD,WAAO,MAAM;AAAA;;AACThB,MAAAA,GAAG,CAAC,0BAAD,CAAH;AACA2C,MAAAA,QAAQ,GAAG,IAAX;AACA,yBAAAiB,cAAc,UAAd;AACH,KAJD;AAKH;AACJ,CA/HM,C,CAgIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React, { useCallback, useContext, useEffect, useReducer } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { getLogger } from \"../core\";\r\nimport { BeautyProps } from \"./BeautyProps\";\r\nimport {\r\n    createBeauties,\r\n    getBeauties,\r\n    newWebSocket,\r\n    updateBeauties,\r\n    eraseBeauty,\r\n} from \"./beautyApi\";\r\nimport {AuthContext} from \"../auth\";\r\n\r\nimport { Plugins } from \"@capacitor/core\"\r\nimport { key } from \"ionicons/icons\";\r\nconst { Storage } = Plugins;\r\n\r\nconst log = getLogger(\"BeautyProvider\");\r\n\r\ntype SaveBeautyFn = (beauty: { ocupat: boolean; data: string; servicii: string; nrPeroane: number; _id?: string; nume: string; ora: string; nrPersoane: number } | { ocupat: boolean; data: string; servicii: string; nume: string; ora: string; nrPersoane: number }) => Promise<any>;\r\ntype DeleteBeautyFn = (beauty: { ocupat: boolean; data: string; servicii: string; nrPeroane: number; _id?: string; nume: string; ora: string; nrPersoane: number } | { ocupat: boolean; data: string; servicii: string; nume: string; ora: string; nrPersoane: number }) => Promise<any>;\r\n\r\nexport interface BeautyState {\r\n    beauties?: BeautyProps[];\r\n    fetching: boolean;\r\n    fetchingError?: Error | null;\r\n    saving: boolean;\r\n    deleting: boolean;\r\n    savingError?: Error | null;\r\n    deletingError?: Error | null;\r\n    saveBeauty?: SaveBeautyFn;\r\n    deleteBeauty?: DeleteBeautyFn;\r\n}\r\n\r\ninterface ActionProps {\r\n    type: string;\r\n    payload?: any;\r\n}\r\n\r\nconst initialState: BeautyState = {\r\n    fetching: false,\r\n    saving: false,\r\n    deleting: false,\r\n};\r\n\r\nconst FETCH_ITEMS_STARTED = \"FETCH_ITEMS_STARTED\";\r\nconst FETCH_ITEMS_SUCCEEDED = \"FETCH_ITEMS_SUCCEEDED\";\r\nconst FETCH_ITEMS_FAILED = \"FETCH_ITEMS_FAILED\";\r\nconst SAVE_ITEM_STARTED = \"SAVE_ITEM_STARTED\";\r\nconst SAVE_ITEM_SUCCEEDED = \"SAVE_ITEM_SUCCEEDED\";\r\nconst SAVE_ITEM_FAILED = \"SAVE_ITEM_FAILED\";\r\nconst DELETE_ITEM_STARTED = \"DELETE_ITEM_STARTED\";\r\nconst DELETE_ITEM_SUCCEEDED = \"DELETE_ITEM_SUCCEEDED\";\r\nconst DELETE_ITEM_FAILED = \"DELETE_ITEM_FAILED\";\r\n\r\nconst reducer: (state: BeautyState, action: ActionProps) => BeautyState = (\r\n    state,\r\n    { type, payload }\r\n) => {\r\n    switch (type) {\r\n        case FETCH_ITEMS_STARTED:\r\n            return {...state, fetching: true, fetchingError: null};\r\n        case FETCH_ITEMS_SUCCEEDED:\r\n            return {...state, beauties: payload.beauties, fetching: false};\r\n        case FETCH_ITEMS_FAILED:\r\n            return {...state, fetchingError: payload.error, fetching: false};\r\n\r\n        case SAVE_ITEM_STARTED:\r\n            return {...state, savingError: null, saving: true};\r\n        case SAVE_ITEM_SUCCEEDED:\r\n            const beauties = [...(state.beauties || [])];\r\n            const beauty = payload.beauty;\r\n            if (beauty != undefined){\r\n                const index = beauties.findIndex((it) => it._id === beauty._id);\r\n                if (index === -1) {\r\n                    beauties.splice(0, 0, beauty);\r\n                } else {\r\n                    beauties[index] = beauty;\r\n                }\r\n                return {...state, beauties, saving: false};\r\n            }\r\n\r\n        case SAVE_ITEM_FAILED:\r\n            return { ...state, savingError: payload.error, saving: false };\r\n\r\n        case DELETE_ITEM_STARTED:\r\n            return { ...state, deletingError: null, deleting: true };\r\n        case DELETE_ITEM_SUCCEEDED: {\r\n            const beauties = [...(state.beauties || [])];\r\n            const beauty = payload.beauty;\r\n            const index = beauties.findIndex((it) => it._id === beauty._id);\r\n            beauties.splice(index, 1);\r\n            return { ...state, beauties, deleting: false };\r\n        }\r\n\r\n        case DELETE_ITEM_FAILED:\r\n            return { ...state, deletingError: payload.error, deleting: false };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\nexport const BeautyContext = React.createContext<BeautyState>(initialState);\r\n\r\ninterface BeautyProviderProps {\r\n    children: PropTypes.ReactNodeLike;\r\n}\r\n\r\nexport const BeautyProvider: React.FC<BeautyProviderProps> = ({ children }) => {\r\n    const { token } = useContext(AuthContext);\r\n    const [state, dispatch] = useReducer(reducer, initialState);\r\n    const {\r\n        beauties,\r\n        fetching,\r\n        fetchingError,\r\n        saving,\r\n        savingError,\r\n        deleting,\r\n    } = state;\r\n    useEffect(getBeautiesEffect, [token]);\r\n    useEffect(wsEffect, [token]);\r\n    const saveBeauty = useCallback<SaveBeautyFn>(saveBeautyCallback, [token]);\r\n    const deleteBeauty = useCallback<DeleteBeautyFn>(deleteBeautyCallback, [token]);\r\n    const value = {\r\n        beauties,\r\n        fetching,\r\n        fetchingError,\r\n        saving,\r\n        savingError,\r\n        saveBeauty,\r\n        deleting,\r\n        deleteBeauty,\r\n    };\r\n    log(\"returns\");\r\n    return <BeautyContext.Provider value={value}>{children}</BeautyContext.Provider>;\r\n\r\n    function getBeautiesEffect() {\r\n        let canceled = false;\r\n        fetchBeauties();\r\n        return () => {\r\n            canceled = true;\r\n        };\r\n\r\n        async function fetchBeauties() {\r\n            if (!token?.trim()) {\r\n                return;\r\n            }\r\n            try {\r\n                log(\"fetchBeauties started\");\r\n                dispatch({ type: FETCH_ITEMS_STARTED });\r\n                const beauties = await getBeauties(token);\r\n                log(\"fetchBeauties succeeded\");\r\n                if (!canceled) {\r\n                    dispatch({ type: FETCH_ITEMS_SUCCEEDED, payload: { beauties } });\r\n                }\r\n            } catch (error) {\r\n                log(\"fetchBeauties failed\");\r\n                let realKeys: string[] = [];\r\n                await Storage.keys().then( (keys)  => {\r\n                    return keys.keys.forEach(function (value) {\r\n                        if (value !== \"user\")\r\n                            realKeys.push(value);\r\n                    })\r\n                });\r\n\r\n                let values: string[] = [];\r\n                for (const key1 of realKeys) {\r\n                    await Storage.get({key: key1}).then((value)=>{\r\n                        // @ts-ignore\r\n                        values.push(value.value);\r\n                    })\r\n                }\r\n                const beauties: BeautyProps[] = [];\r\n                for(const value of values){\r\n                    var beauty = JSON.parse(value);\r\n                    beauties.push(beauty);\r\n                }\r\n                log(beauties);\r\n                if (!canceled) {\r\n                    dispatch({type: FETCH_ITEMS_SUCCEEDED, payload: {beauties}});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async function saveBeautyCallback(beauty: BeautyProps) {\r\n        try {\r\n            log(\"saveBeauty started\");\r\n\r\n            dispatch({ type: SAVE_ITEM_STARTED });\r\n            const savedBeauty = await (beauty._id\r\n                ? updateBeauties(token, beauty)\r\n                : createBeauties(token, beauty));\r\n            log(\"saveBeauty succeeded\");\r\n            dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { beauty: savedBeauty } });\r\n        } catch (error) {\r\n            log(\"saveBeauty failed\");\r\n            dispatch({ type: SAVE_ITEM_FAILED, payload: { error } });\r\n        }\r\n    }\r\n\r\n    async function deleteBeautyCallback(beauty: BeautyProps) {\r\n        try {\r\n            log(\"delete started\");\r\n            dispatch({ type: DELETE_ITEM_STARTED });\r\n            const deletedBeauty = await eraseBeauty(token, beauty);\r\n            log(\"delete succeeded\");\r\n            console.log(deletedBeauty);\r\n            dispatch({ type: DELETE_ITEM_SUCCEEDED, payload: { beauty: beauty } });\r\n        } catch (error) {\r\n            log(\"delete failed\");\r\n            dispatch({ type: DELETE_ITEM_FAILED, payload: { error } });\r\n        }\r\n    }\r\n\r\n    function wsEffect() {\r\n        let canceled = false;\r\n        log(\"wsEffect - connecting\");\r\n        let closeWebSocket: () => void;\r\n        if (token?.trim()) {\r\n            closeWebSocket = newWebSocket(token, (message) => {\r\n                if (canceled) {\r\n                    return;\r\n                }\r\n                const { type, payload: carte } = message;\r\n                log(`ws message, carte ${type}`);\r\n\r\n            });\r\n        }\r\n        return () => {\r\n            log(\"wsEffect - disconnecting\");\r\n            canceled = true;\r\n            closeWebSocket?.();\r\n        };\r\n    }\r\n};\r\n// import React, { useCallback, useEffect, useReducer, useContext } from 'react';\r\n// import PropTypes from 'prop-types';\r\n// import { getLogger } from '../core';\r\n// import { BeautyProps } from './BeautyProps';\r\n// import { createBeauties, getBeauties, updateBeauties, newWebSocket, eraseBeauty } from './beautyApi';\r\n//\r\n// const log = getLogger('BeautyProvider');\r\n//\r\n// type SaveItemFn = (item: BeautyProps) => Promise<any>;\r\n//\r\n// export interface ItemsState {\r\n//     items?: BeautyProps[],\r\n//     fetching: boolean,\r\n//     fetchingError?: Error | null,\r\n//     saving: boolean,\r\n//     savingError?: Error | null,\r\n//     saveItem?: SaveItemFn,\r\n// }\r\n//\r\n// interface ActionProps {\r\n//     type: string,\r\n//     payload?: any,\r\n// }\r\n//\r\n// const initialState: ItemsState = {\r\n//     fetching: false,\r\n//     saving: false,\r\n// };\r\n//\r\n// const FETCH_ITEMS_STARTED = 'FETCH_ITEMS_STARTED';\r\n// const FETCH_ITEMS_SUCCEEDED = 'FETCH_ITEMS_SUCCEEDED';\r\n// const FETCH_ITEMS_FAILED = 'FETCH_ITEMS_FAILED';\r\n// const SAVE_ITEM_STARTED = 'SAVE_ITEM_STARTED';\r\n// const SAVE_ITEM_SUCCEEDED = 'SAVE_ITEM_SUCCEEDED';\r\n// const SAVE_ITEM_FAILED = 'SAVE_ITEM_FAILED';\r\n//\r\n// const reducer: (state: ItemsState, action: ActionProps) => ItemsState =\r\n//     (state, { type, payload }) => {\r\n//         switch(type) {\r\n//             case FETCH_ITEMS_STARTED:\r\n//                 return { ...state, fetching: true, fetchingError: null };\r\n//             case FETCH_ITEMS_SUCCEEDED:\r\n//                 return { ...state, items: payload.items, fetching: false };\r\n//             case FETCH_ITEMS_FAILED:\r\n//                 return { ...state, fetchingError: payload.error, fetching: false };\r\n//             case SAVE_ITEM_STARTED:\r\n//                 return { ...state, savingError: null, saving: true };\r\n//             case SAVE_ITEM_SUCCEEDED:\r\n//                 const items = [...(state.items || [])];\r\n//                 const item = payload.item;\r\n//                 const index = items.findIndex(it => it.id === item.id);\r\n//                 if (index === -1) {\r\n//                     items.splice(0, 0, item);\r\n//                 } else {\r\n//                     items[index] = item;\r\n//                 }\r\n//                 return { ...state,  items, saving: false };\r\n//             case SAVE_ITEM_FAILED:\r\n//                 return { ...state, savingError: payload.error, saving: false };\r\n//             default:\r\n//                 return state;\r\n//         }\r\n//     };\r\n//\r\n// export const ItemContext = React.createContext<ItemsState>(initialState);\r\n//\r\n// interface ItemProviderProps {\r\n//     children: PropTypes.ReactNodeLike,\r\n// }\r\n//\r\n// export const BeautyProvider: React.FC<ItemProviderProps> = ({ children }) => {\r\n//     const [state, dispatch] = useReducer(reducer, initialState);\r\n//     const { items, fetching, fetchingError, saving, savingError } = state;\r\n//     useEffect(getItemsEffect, []);\r\n//     const saveItem = useCallback<SaveItemFn>(saveItemCallback, []);\r\n//     const value = { items, fetching, fetchingError, saving, savingError, saveItem };\r\n//     log('returns');\r\n//     return (\r\n//         <ItemContext.Provider value={value}>\r\n//             {children}\r\n//         </ItemContext.Provider>\r\n//     );\r\n//\r\n//     function getItemsEffect() {\r\n//         let canceled = false;\r\n//         fetchItems();\r\n//         return () => {\r\n//             canceled = true;\r\n//         }\r\n//\r\n//         async function fetchItems() {\r\n//             try {\r\n//                 log('fetchItems started');\r\n//                 dispatch({ type: FETCH_ITEMS_STARTED });\r\n//                 const items = await getItems();\r\n//                 log('fetchItems succeeded');\r\n//                 if (!canceled) {\r\n//                     dispatch({ type: FETCH_ITEMS_SUCCEEDED, payload: { items } });\r\n//                 }\r\n//             } catch (error) {\r\n//                 log('fetchItems failed');\r\n//                 dispatch({ type: FETCH_ITEMS_FAILED, payload: { error } });\r\n//             }\r\n//         }\r\n//     }\r\n//\r\n//     async function saveItemCallback(item: BeautyProps) {\r\n//         try {\r\n//             log('saveItem started');\r\n//             dispatch({ type: SAVE_ITEM_STARTED });\r\n//             const savedItem = await (item.id ? updateItem(item) : createItem(item));\r\n//             log('saveItem succeeded');\r\n//             dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { item: savedItem } });\r\n//         } catch (error) {\r\n//             log('saveItem failed');\r\n//             dispatch({ type: SAVE_ITEM_FAILED, payload: { error } });\r\n//         }\r\n//     }\r\n// };\r\n"]},"metadata":{},"sourceType":"module"}